# init-project

You are the BOOTSTRAP ENGINEER for the EasyHeadHunter project. Initialize a clean monorepo with an Event-Log-first foundation using FastAPI + Postgres (Alembic migrations) and a minimal Next.js frontend.  Non-negotiable principles - Event-Log-first: business actions emit immutable domain events into the event_store table. - Projections/read models can be rebuilt from the event log (idempotent projectors). - Monorepo with clear separation: backend, frontend, shared. - Minimal, runnable, CI-friendly skeleton. No overengineering.  Tech decisions (fixed) - Backend: Python + FastAPI - DB: Postgres - Migrations: Alembic - Tests: Pytest - Frontend: Next.js (TypeScript) - Frontend tests: Playwright (placeholder) - Python dependency mgmt: requirements.txt (keep it simple)  Task 1) Create the folder structure exactly as specified below. 2) Create all required files with sensible, working contents. 3) Backend must start and answer /health even if Postgres is not available (in-memory fallback for events). 4) If Postgres is available, /events must persist and read from DB. 5) Add docs + scripts for dev/test/format. 6) Do NOT implement product features beyond the event store skeleton.  Target folder structure (create exactly)  /README.md /docs   /architecture.md   /events.md   /dev-process.md   /testing.md /backend   /app     /main.py     /api       /routes_health.py       /routes_events.py     /core       /config.py       /logging.py     /db       /session.py       /models.py       /migrations         /alembic.ini         /env.py         /script.py.mako         /versions           /0001_create_event_store.py     /domain       /events         /event_types.py         /schemas.py         /event_store.py       /projections         /projector_base.py         /projector_registry.py     /services       /event_service.py   /tests     /test_health.py     /test_event_store_contract.py   /requirements.txt   /Dockerfile /frontend   /src     /app       /page.tsx       /layout.tsx     /components       /EventTimeline.tsx     /lib       /api.ts       /types.ts   /package.json   /next.config.js   /tsconfig.json   /playwright.config.ts   /tests     /golden-path.spec.ts /shared   /events     /schema.json     /types.ts     /types.py /scripts   /dev.sh   /format.sh   /test.sh /.editorconfig /.gitignore  Backend requirements (must be runnable) - FastAPI app with:   - GET /health -> { "status": "ok" }   - POST /events -> append an event   - GET /events?limit=50 -> list latest N events (newest first) - Event schema fields:   event_id (uuid)   ts (ISO8601 timestamptz)   actor (string)   entity_type (string)   entity_id (string)   event_type (string)   payload (object)   source (string)   schema_version (int) - Postgres persistence:   - SQLAlchemy model in backend/app/db/models.py   - Alembic migration creates event_store table with indices on (ts) and (entity_type, entity_id) - In-memory fallback:   - If DATABASE_URL is missing or connection fails, store events in a process-local list.   - Document this clearly. - Use Pydantic models for request/response.  Backend dependency list (backend/requirements.txt) - fastapi - uvicorn[standard] - pydantic - sqlalchemy - psycopg2-binary (or asyncpg if you choose async, but keep it synchronous for MVP) - alembic - python-dotenv - pytest - httpx (for test client if needed)  Frontend requirements (minimal runnable) - Next.js page showing:   - Health status (calls backend /health)   - Event timeline list (calls backend /events) - Provide a tiny API wrapper and TS types aligned with shared schema. - Use a simple component EventTimeline.tsx.  Design init (mandatory) - After creating the frontend skeleton, apply the futuristic UI system as defined in `.cursor/commands/init-design.md` (#init_futuristic_ui). - Include: design tokens (colors, typography, spacing, radius, shadows, glow), theme (dark-first, charcoal background, electric blue accent), core UI primitives (Button, Card, Input, Badge, Section, Page container), and futuristic styling rules (glow on focus/primary only, 3-level depth, 150â€“250ms ease-out motion). - Build the initial page and EventTimeline using these components and tokens so the UI is futuristic from day one.  Shared requirements - shared/events/schema.json contains canonical event schema with schema_version. - shared/events/types.ts and types.py define the event type structures aligned with schema.  Docs requirements - docs/events.md: event format, naming conventions for event_type, schema_versioning rules - docs/architecture.md: components, event store + projections concept, rebuild-from-log - docs/dev-process.md: branching, PR notes template, agent workflow (PM/DEV/TEST/REVIEW) - docs/testing.md: golden path concept + where tests live  Scripts requirements - scripts/dev.sh:   - instructions to run backend and frontend   - optionally start both via two commands (keep it simple) - scripts/test.sh: run pytest + (optional) playwright placeholder - scripts/format.sh: python formatting instructions (use ruff/black optional, but if you include them add to requirements)  Config files - .gitignore appropriate for python/node - .editorconfig simple defaults  Implementation details you must include - backend/app/core/config.py reads:   - DATABASE_URL (optional)   - APP_ENV   - CORS_ORIGINS (default *) - backend/app/main.py wires routes, CORS middleware, and chooses DB/in-memory event store based on availability. - backend/app/domain/events/event_store.py provides interface:   - append(event)   - list(limit)   and two implementations:   - PostgresEventStore   - InMemoryEventStore - backend/app/services/event_service.py is the only layer the routes call. - Provide at least:   - backend/tests/test_health.py   - backend/tests/test_event_store_contract.py (append/list contract, works with in-memory store)  Output format - Create the files with full contents (not placeholders) wherever possible. - For Playwright golden-path.spec.ts, include a TODO scenario outline. - At the end, print:   1) how to run backend (commands)   2) how to run frontend (commands)   3) how to run tests (commands)   4) environment variables needed (DATABASE_URL optional)   5) note that the frontend uses the futuristic UI system (init-design / #init_futuristic_ui)  Quality gates - Minimal, clean, consistent. - No secrets committed. - No microservices, no kafka, no temporal.
